/// <reference types="node" />
import type { FilterExpression } from './filterParser';
import type { IncomingHttpHeaders } from 'http';
import type { DataAccess } from '../data/dataAccess';
export type ExpandDefinition = {
    expand: Record<string, ExpandDefinition>;
    properties: Record<string, boolean>;
};
type ODataRequestContent = {
    body?: any;
    url: string;
    tenantId?: string;
    method: string;
    headers?: IncomingHttpHeaders;
    contentId?: string;
};
type OrderByDefinition = {
    name: string;
    direction: 'asc' | 'desc';
};
export type QueryPath = {
    path: string;
    keys: Record<string, any>;
};
type AggregateDefinition = {
    filter?: FilterExpression;
    groupBy: string[];
    aggregates: AggregateProperty[];
};
type AggregateProperty = {
    name: string;
    operator: string;
    sourceProperty: string;
};
export default class ODataRequest {
    private requestContent;
    private dataAccess;
    private isMinimalRepresentation;
    tenantId: string;
    queryPath: QueryPath[];
    searchQuery: string[];
    orderBy: OrderByDefinition[];
    startIndex: number;
    maxElements: number;
    aggregateDefinition?: AggregateDefinition;
    filterDefinition?: FilterExpression;
    selectedProperties: Record<string, boolean>;
    expandProperties: Record<string, ExpandDefinition>;
    responseHeaders: Record<string, string>;
    statusCode: number;
    dataCount: number;
    countRequested: boolean;
    responseData: any;
    private allParams;
    private context;
    private messages;
    constructor(requestContent: ODataRequestContent, dataAccess: DataAccess);
    private parseParameters;
    /**
     * Split a list of properties that can contain sub-requests into an array.
     *
     * @param propertiesQuery OData properties request
     * @param delimiter Property delimiter
     * @returns an array of string with the properties
     */
    private splitProperties;
    private parseExpand;
    private parseOrderBy;
    private parsePath;
    private parseApply;
    private parseAggregateDefinition;
    handleRequest(): Promise<void>;
    setResponseData(data: any): void;
    setContext(context: string): void;
    getResponseData(): string | null | undefined;
    addMessage(code: number, message: string, severity: number, target: string): void;
    addCustomMessage(messageData: any): void;
    addResponseHeader(headerName: string, headerValue: string): void;
    setDataCount(dataCount: number): void;
}
export {};
//# sourceMappingURL=odataRequest.d.ts.map