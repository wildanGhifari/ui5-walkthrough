"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StickyMockEntitySet = void 0;
const entitySet_1 = require("./entitySet");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const common_1 = require("../common");
/**
 *
 */
class StickyMockEntitySet extends entitySet_1.MockDataEntitySet {
    constructor(rootFolder, entitySetDefinition, dataAccess, generateMockData) {
        var _a, _b, _c;
        super(rootFolder, entitySetDefinition, dataAccess, generateMockData);
        this._currentSessionObject = {};
        this.sessionTimeoutTime = 120;
        const discardAction = (_b = (_a = entitySetDefinition.annotations.Session) === null || _a === void 0 ? void 0 : _a.StickySessionSupported) === null || _b === void 0 ? void 0 : _b.DiscardAction;
        if (discardAction) {
            // determine the (unbound) discard action.
            const metadata = dataAccess.getMetadata();
            const entityContainerPath = metadata.getEntityContainerPath();
            /*
             TODO: Most (all?) of the existing services incorrectly annotate the 'discard' action by its short action
                   name. This code prepends the entity container path if needed so that it can be resolved based on
                   the action import.
            */
            const actionImportFQN = !discardAction.startsWith(entityContainerPath)
                ? `${entityContainerPath}/${discardAction}`
                : `${discardAction}`;
            this.discardAction = (_c = metadata.getActionImportByFQN(actionImportFQN)) === null || _c === void 0 ? void 0 : _c.action;
        }
    }
    getSessionObject(tenantId) {
        return this._currentSessionObject[tenantId];
    }
    setSessionObject(tenantId, objectData) {
        this._currentSessionObject[tenantId] = objectData;
    }
    resetSessionTimeout(tenantId) {
        clearTimeout(this.sessionTimeoutRef);
        this.sessionTimeoutRef = setTimeout(() => {
            this.currentUUID = undefined;
            this.setSessionObject(tenantId, null);
        }, this.sessionTimeoutTime * 1000);
        return this.currentUUID;
    }
    async performPATCH(keyValues, patchData, tenantId, odataRequest) {
        keyValues = this.prepareKeys(keyValues);
        const data = this.performGET(keyValues, false, tenantId, odataRequest);
        const currentMockData = this.getMockData(tenantId);
        const updatedData = Object.assign(data, patchData);
        await currentMockData.onBeforeUpdateEntry(keyValues, updatedData, odataRequest);
        if (updatedData.__transient) {
            this.setSessionObject(tenantId, updatedData);
        }
        else {
            await currentMockData.updateEntry(keyValues, updatedData, patchData, odataRequest);
        }
        await currentMockData.onAfterUpdateEntry(keyValues, updatedData, odataRequest);
        return updatedData;
    }
    async executeAction(actionDefinition, actionData, odataRequest, keys) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const currentMockData = this.getMockData(odataRequest.tenantId);
        keys = this.prepareKeys(keys);
        actionData = await currentMockData.onBeforeAction(actionDefinition, actionData, keys, odataRequest);
        let responseObject;
        switch (actionDefinition.fullyQualifiedName) {
            // Draft Edit Action
            case `${(_d = (_c = (_b = (_a = this.entitySetDefinition) === null || _a === void 0 ? void 0 : _a.annotations) === null || _b === void 0 ? void 0 : _b.Session) === null || _c === void 0 ? void 0 : _c.StickySessionSupported) === null || _d === void 0 ? void 0 : _d.EditAction}(${actionDefinition.sourceType})`: {
                const data = this.performGET(keys, false, odataRequest.tenantId, odataRequest);
                const duplicate = Object.assign({}, data);
                this.setSessionObject(odataRequest.tenantId, duplicate);
                this.addSessionToken(odataRequest);
                duplicate.__transient = true;
                duplicate.__keys = keys;
                responseObject = duplicate;
                break;
            }
            case `${(_h = (_g = (_f = (_e = this.entitySetDefinition) === null || _e === void 0 ? void 0 : _e.annotations) === null || _f === void 0 ? void 0 : _f.Session) === null || _g === void 0 ? void 0 : _g.StickySessionSupported) === null || _h === void 0 ? void 0 : _h.NewAction}(${actionDefinition.sourceType})`: {
                // New
                let newObject = currentMockData.getEmptyObject(odataRequest);
                newObject = Object.assign(newObject, actionData);
                this.setSessionObject(odataRequest.tenantId, newObject);
                newObject.__transient = true;
                odataRequest.setContext(`../$metadata#${(_j = this.entitySetDefinition) === null || _j === void 0 ? void 0 : _j.name}()/$entity`);
                this.addSessionToken(odataRequest);
                this.resetSessionTimeout(odataRequest.tenantId);
                responseObject = newObject;
                break;
            }
            case (_k = this.discardAction) === null || _k === void 0 ? void 0 : _k.fullyQualifiedName:
                // Discard
                this.setSessionObject(odataRequest.tenantId, null);
                responseObject = null;
                break;
            case `${(_p = (_o = (_m = (_l = this.entitySetDefinition) === null || _l === void 0 ? void 0 : _l.annotations) === null || _m === void 0 ? void 0 : _m.Session) === null || _o === void 0 ? void 0 : _o.StickySessionSupported) === null || _p === void 0 ? void 0 : _p.SaveAction}(${actionDefinition.sourceType})`: {
                const newData = this.getSessionObject(odataRequest.tenantId);
                if (newData.__keys) {
                    // Key needs to be filled now
                    await currentMockData.updateEntry(newData.__keys, newData, newData, odataRequest);
                }
                else {
                    await this.performPOST({}, newData, odataRequest.tenantId, odataRequest);
                }
                this.setSessionObject(odataRequest.tenantId, null);
                responseObject = newData;
                break;
            }
            default:
                break;
        }
        responseObject = await currentMockData.onAfterAction(actionDefinition, actionData, keys, responseObject, odataRequest);
        return responseObject;
    }
    addSessionToken(odataRequest) {
        const uuid = (0, common_1.generateId)(16);
        this.currentUUID = uuid;
        odataRequest.addResponseHeader('sap-contextid', 'SID:ANON:' + uuid);
        odataRequest.addResponseHeader('sap-http-session-timeout', this.sessionTimeoutTime.toString());
    }
    performGET(keyValues, asArray, tenantId, odataRequest, dontClone = false) {
        const currentSessionObject = this.getSessionObject(tenantId);
        if (currentSessionObject && keyValues && Object.keys(keyValues).length) {
            if ((Object.prototype.hasOwnProperty.call(keyValues, "''") && keyValues["''"] === undefined) ||
                this.checkKeys(keyValues, currentSessionObject, this.entityTypeDefinition.keys)) {
                if (odataRequest) {
                    odataRequest.addResponseHeader('sap-contextid', 'SID:ANON:' + this.currentUUID);
                    odataRequest.addResponseHeader('sap-http-session-timeout', this.sessionTimeoutTime.toString());
                }
                this.resetSessionTimeout(tenantId);
                return (0, lodash_clonedeep_1.default)(currentSessionObject);
            }
        }
        return super.performGET(keyValues, asArray, tenantId, odataRequest, dontClone);
    }
    isDiscardAction(action) {
        return action === this.discardAction;
    }
}
exports.StickyMockEntitySet = StickyMockEntitySet;
//# sourceMappingURL=stickyEntitySet.js.map